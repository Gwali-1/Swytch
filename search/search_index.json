{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Swytch","text":"<p>Hello, and welcome to the  Swytch docs! Swytch (pronounced \"switch\" like the network device or a light bulb switch)  is a web framework written in C#. It is lightweight, fast and offers an alternative and refreshing way to author web services . Swytch focuses on minimal abstraction, allowing developers more control over their applications while simplifying repetitive tasks.</p> <p>Swytch is built on HttpListener for a lightweight, programmatically controlled HTTP server,  RazorLight for dynamic content rendering with Razor syntax, Dapper for efficient database interactions,  and Akka.NET for the actor based concurrency functionality it provides. </p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Swytch follows a simple philosophy, \"Do less, so you can do more\". Instead of imposing a load of rigid conventions, it provides just enough abstraction to handle common tasks efficiently while giving you, the developer full control over your code. Swytch is designed for those who enjoy recreational programming and want a framework that stays out of their way.  If that sounds like you or if you're open to making a switch (pun intended) and try something new, then I encourage you to approach Swytch with an open mind. It\u2019s not meant to be like anything you\u2019ve used before. The project is still young, and there's plenty of room for growth. Many features could be built in to further simplify development and hopefully,  contributions through pull requests will help shape Swytch into something even better.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Get started with Installation and then get an overview of what a Swytch application looks like with the Quickstart.  There is also a more detailed Tutorial that shows how to create a small but complete application with Swytch.  The Guide section also shows how to set up and use various features and functionality built into Swytch in detail.</p>"},{"location":"#note","title":"Note","text":"<p>I (Gwalisam) started Swytch as an educational project to explore C# as a language and to experiment with a lightweight alternative for building simple web services or hacking on personal projects without the overhead of ASP.NET/ASP.NET CORE. It has been a rewarding experience, and I learned a lot along the way. I work on Swytch in my spare time, balancing it with my professional life and the other million things I have on my desk. It took almost a year to get Swytch to a point where I felt it was stable enough to share. Since I only work on this when I can afford to, I kindly ask for patience when raising issues or reporting bugs. I'll address them as soon as I can.</p>"},{"location":"ActorPool/","title":"Swytch ActorPool","text":"<p>Swytch provides built-in support for concurrent and background task execution using independent units of computations  known as Actors. Swytch does this through a preconfigured Actor system built on top of the powerful Akka.NET framework and exposing simple, intuitive  APIs that allow you to  register actors and then send them tasks to be executed.</p>"},{"location":"ActorPool/#understanding-the-actor-model","title":"Understanding the Actor Model","text":"<p>The Actor Model is a concurrency model that treats actors as the fundamental units of computation. Unlike traditional concurrency approaches in C# such as using <code>Threads</code>, <code>Tasks</code>, or the <code>ThreadPool</code> where memory is  shared and hence synchronization  techniques like <code>locks</code>, <code>semaphores</code> are common to avoid some of the challenges that concurrency presents, the actor model promotes a message-passing architecture which helps avoid these challenges by design.</p> <p>How is it different?</p> <p>In the Actor Model there is no shared state. Each actor encapsulates its own state. This removes the need for locks or mutexes to protect shared data.</p> <p>Also, Actors communicate exclusively through asynchronous messages. One actor sends a message to another, which is then processed in isolation.</p> <p>Now  Since actors don't share memory, failures in one actor do not affect others. They can also supervise and restart each other in case of failures making them resilient.</p> <p>Another important feature of this model is there is sequential execution of task per Actor. Actors communicate through messaging  and each upon receiving messages  processes one message at a time, avoiding race conditions by design.</p> <p>This model makes concurrent and parallel execution more robust, scalable, and easier to reason about especially in complex systems. Swytch provides a very lightweight and intuitive abstraction to work with the actor model and take  advantage of its qualities in your applications easily. It provides APIs that will allow you to perform actions like registering these actors and also sending them messages to trigger a task to be executed in the actor pool. We'll take  a look at how to use actors in swytch in more detail below</p> <p>This are some useful links to read more about the actor model</p> <ul> <li>Actor-Model System with Akka.NET</li> <li>When and How to Use the Actor Model An Introduction to Akka NET Actors</li> </ul>"},{"location":"ActorPool/#swytch-actor-pool","title":"Swytch Actor Pool","text":"<p>Swytch makes it easy to use the Actor Model through a static utility class called <code>ActorPool</code>. This class provides methods for initializing the pool, registering your actor types, and sending messages to them.</p> <p>Swytch internally leverages Akka.NET to implement its actor pool(Actor System). It wraps around some of the Akka.NET complexity and exposes methods on a  utility class called <code>ActorPool</code> that allows you to initialize and interact with the actor infrastructure seamlessly.</p> <p>Let's explore how to use it...</p> <p>Before using the actor pool, you must initialize it with your application's <code>IServiceProvider</code>.</p>"},{"location":"ActorPool/#initializeactorpool","title":"InitializeActorPool","text":"<p>The <code>InitializeActorPool</code> method is used to initialize the actor pool for your Swytch application. This method requires the <code>IServiceProvider</code> parameter to set up the actor pool in such a way that your actors can leverage dependency injection (DI). By passing the service provider to this method, you enable your actors to automatically resolve and use any services registered in the DI container. This simplifies the implementation of actors because you don't have to manually manage dependencies within them. Instead, you register all the services an actor might need in the service provider and pass that provider when initializing the actor pool. The pool ensures that each actor is properly constructed with its dependencies injected when executed.</p> <p>This method is essential and must be called first. If you attempt to use the actor pool or any related methods before calling this method, an <code>InvalidOperationException</code> will be thrown.</p>"},{"location":"ActorPool/#example","title":"Example","text":"<pre><code> // Create a service collection and register the services that you inject into your actor classes\n   var serviceCollection = new ServiceCollection();\n   serviceCollection.AddSingleton&lt;MyService&gt;();\n\n // Build the service provider\n    var serviceProvider = serviceCollection.BuildServiceProvider();\n\n // Initialize the actor pool with the service provider\n ActorPool.InitializeActorPool(serviceProvider);\n</code></pre>"},{"location":"ActorPool/#register","title":"Register","text":"<p>After initializing your actor pool using the <code>InitializeActorPool</code> method, you can register your custom actor implementations into the pool. The <code>Register&lt;T&gt;</code> method allows you to register an actor that will be used for future executions.</p> <p>This method takes a class of type <code>T</code> that must inherit from <code>ActorBase</code>, which marks it as a valid actor in Swytch. By doing this, Swytch adds your actor to its internal actor pool, where it is equipped with routers to manage and execute tasks concurrently.</p> <p>Swytch automatically adjusts the number of actor instances in the pool based on demand, with an upper limit of one million instances. This ensures that the system dynamically scales by creating more actor instances when necessary to improve throughput and execution speed, while also preventing resource wastage by maintaining a manageable number of instances when demand is low.</p> <p>You can pass an optional <code>instances</code> parameter to specify the minimum number of actor instances you want to be available in the pool at all times. This allows you to ensure that a certain number of actor instances are ready to handle tasks, even during low-demand periods.</p> <p>Important: You cannot register the same actor type multiple times. If you attempt to do so, an <code>InvalidOperationException</code> will be thrown.</p> <p>Once an actor is registered, you can send messages to it using the <code>Tell</code> method to trigger actions in the actor.</p>"},{"location":"ActorPool/#example_1","title":"Example","text":"<p>Let's look at a simple example of how you would write  an actor that receives a message and logs it:</p> <pre><code>public class LoggingActor : ReceiveActor\n{\n    private readonly ILogger&lt;LoggingActor&gt; _logger;\n\n    public LoggingActor(ILogger&lt;LoggingActor&gt; logger)\n    {\n        _logger = logger;\n\n        // Define how the actor will handle messages of type string\n        Receive&lt;string&gt;(message =&gt;\n        {\n            _logger.LogInformation($\"Logging Actor recieved message = {message}\");\n        });\n    }\n}\n</code></pre> <p>The <code>LoggingActor</code> class inherits from the <code>ReceiveActor</code> base class, which is a base class provided by Akka.NET to indicate that this is actor that is meant to receive messages  and react to them.</p> <p>It uses dependency injection to receive an ILogger, which allows it to log messages. In the actor's constructor, the logger is injected, and the actor is set up to handle messages of type string.  <p>When a message of this type is received, the actor logs the message using the injected logger. This shows how actors in Swytch can use dependency injection for external services and perform specific actions, such as logging, upon receiving messages.</p> <p>Register the actor</p> <p>You will register the above actor like this <pre><code>ActorPool.Register&lt;LogActor&gt;(instances: 2); // Register LogActor with a minimum of 2 instances\n</code></pre> This registeres and ensures that there will always be at least 2 instances of the LogActor available to process messages.  Swytch will handle scaling the number of actor instances based on the system's demand.</p>"},{"location":"ActorPool/#tell","title":"Tell","text":"<p>Once registered, you can send a message to the actor using the <code>Tell</code> method. The <code>Tell</code> method is used to send a message to a registered actor in the actor pool.  This is a generic method takes two parameters.</p> <p>T specifies the type of the actor that will receive the message.</p> <p>TM is the type of the message being sent to the actor.</p> <p>When a message is sent using this method, Swytch identifies the actor in the pool by the actor type T, and it sends  the specified message of type TM to it. </p> <p>The actor must be set up to receive and  process messages of type TM. </p> <p>If an actor is not registered in the pool or if the actor does not have a handler for the provided message type, nothing happens(the message is dropped), and in the case of an unregistered actor, an <code>InvalidOperationException</code> will be thrown.</p> <p>This method allows for flexible message passing to actors, ensuring that the actor processes messages of the correct type, while also ensuring that only valid actors in the pool handle the incoming messages</p>"},{"location":"ActorPool/#example_2","title":"Example","text":"<pre><code>ActorPool.Tell&lt;LogActor, string&gt;(\"Hello, Actor!\");\n</code></pre> <p>In this example, the Tell method sends the message \"Hello, Actor!\" to one of the available LogActor instances, which will then log the message to the console.</p> <p>By registering your actors and sending messages, you can easily build fast, concurrent, scalable applications using the actor model.</p>"},{"location":"ActorPool/#complete-example","title":"Complete Example","text":"<pre><code>using System;\nusing Microsoft.Extensions.DependencyInjection;\nusing Swytch.ActorSystem;\nusing Microsoft.Extensions.Logging;\nusing System.Threading.Tasks;\n\n// Define the actor class that inherits from ReceiveActor\npublic class LoggingActor : ReceiveActor\n{\n    private readonly ILogger&lt;LoggingActor&gt; _logger;\n\n    // Constructor that takes in the injected logger\n    public LoggingActor(ILogger&lt;LoggingActor&gt; logger)\n    {\n        _logger = logger;\n\n        // Define how the actor should handle messages of type string\n        Receive&lt;string&gt;(message =&gt;\n        {\n            _logger.LogInformation($\"Logging Actor received message: {message}\");\n        });\n    }\n}\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Step 1: Set up the service container and register necessary services\n        var serviceProvider = new ServiceCollection()\n            .AddLogging(builder =&gt; builder.AddConsole()) // Register logging service\n            .BuildServiceProvider();\n\n        // Step 2: Initialize the actor pool using the service provider\n        ActorPool.InitializeActorPool(serviceProvider);\n\n        // Step 3: Register the LoggingActor with the actor pool\n        ActorPool.Register&lt;LoggingActor&gt;(2); // Registering 2 instances of LoggingActor\n\n        // Step 4: Send a message to the registered LoggingActor\n        // This will invoke the Receive method inside LoggingActor and log the message\n        ActorPool.Tell&lt;LoggingActor, string&gt;(\"Hello, Actor!\"); // This sends the message to the LoggingActor\n\n        // Ensure that the actor pool is properly cleaned up if necessary (e.g., if using a real application setup)\n        await Task.Delay(1000); // Wait for the log to be written before application exits\n    }\n}\n</code></pre>"},{"location":"AuthUtility/","title":"Authentication Utilities","text":"<p>Swytch provides a small but useful set of authentication utility methods to help you get started with simple auth flows. These helpers are designed to assist in setting up basic authentication and JWT bearer token validation easily and quickly.</p> <p>The utility methods live under a static class called <code>AuthUtility</code>. They serve as convenience methods to help you prototype or implement simple protection around your Swytch application quickly.</p>"},{"location":"AuthUtility/#basic-authentication","title":"Basic Authentication","text":""},{"location":"AuthUtility/#validatebasicauthscheme","title":"ValidateBasicAuthScheme","text":"<p>This method offers a ready-to-use Basic Authentication check. It allows you to easily authenticate requests using base64-encoded credentials typically sent via the Authorization header in the Basic scheme.</p> <p>It takes 2 parameters</p> <p>context - The current <code>RequestContext</code>, from which headers and request metadata can be accessed.</p> <p>credentials - A string in the format <code>username:password</code> representing the valid credentials to compare against.</p>"},{"location":"AuthUtility/#example","title":"Example","text":"<pre><code>swytchApp.AddAuthentication(async (context) =&gt;\n{    \n    var authResult = AuthUtility.ValidateBasicAuthScheme(context, \"admin:secret\");\n    if (authResult.IsAuthenticated)\n    {\n    //optionally add more claims\n     authResult.claimsPrincipal.Claims.Append(new Claim(ClaimTypes.Age, 45));\n     return authResult;\n    }\n\n    return authResult;\n});\n</code></pre> <p>In the example above, we use the built-in <code>AuthUtility.ValidateBasicAuthScheme</code> method to perform basic authentication using a hardcoded credential <code>admin:secret</code>.</p> <p>When a request includes basic authentication headers, the <code>ValidateBasicAuthScheme</code> method automatically decodes the credentials and checks them against the expected string provided (<code>admin:secret</code>).</p> <p>If the credentials match, the method returns an authenticated <code>AuthResponse</code> that includes a ClaimsPrincipal with a single default claim, the <code>ClaimTypes.Name</code>, which is set to the username part of the basic auth string.</p> <p>You can customize this further by appending additional claims to the <code>ClaimsPrincipal</code> object before returning the response, allowing for extended identity or authorization handling within your application.</p>"},{"location":"AuthUtility/#bearer-authentication-jwt","title":"Bearer Authentication (JWT)","text":""},{"location":"AuthUtility/#createbearertoken","title":"CreateBearerToken","text":"<p>This helper method makes it easy to create a JWT bearer token without the boilerplate. You provide a secret key, how long the token should live (in seconds), and a list of claims to embed in the token payload.</p> <p>The method takes 3 parameters</p> <p>secretKey - A string used to sign the JWT.</p> <p>lifeExpireSeconds - How long the token should be valid, from now.</p> <p>claims - A list of System.Security.Claims.Claim objects to attach to the token.</p>"},{"location":"AuthUtility/#example_1","title":"Example","text":"<pre><code>var claims = new List&lt;Claim&gt;\n{\n    new Claim(ClaimTypes.NameIdentifier, \"user123\"),\n    new Claim(ClaimTypes.Role, \"admin\")\n};\n\nvar token = AuthUtility.CreateBearerToken(\"my-super-secret\", 3600, claims);\n</code></pre>"},{"location":"AuthUtility/#validatebearertoken","title":"ValidateBearerToken","text":"<p>This method is a convenience implementation for validating a JWT Bearer Token. It parses and validates a JWT string ( token) using the rules specified in the provided TokenValidationParameters.</p> <p>The method takes in 3 parameters.</p> <p>context - The current RequestContext.</p> <p>token - The raw JWT string from the client, usually from the Authorization: Bearer token header.</p> <p>tokenValidationParameters - An instance of TokenValidationParameters, where you define how the token should be validated (issuer, audience, expiry, clock skew, etc.).</p>"},{"location":"AuthUtility/#example_2","title":"Example","text":"<pre><code>swytchApp.AddAuthentication(async (context) =&gt;\n{  \nvar validationParams = new TokenValidationParameters\n{\n    ValidateIssuer = true,\n    ValidIssuer = \"swytch-api\",\n    ValidateAudience = true,\n    ValidAudience = \"swytch-clients\",\n    ValidateLifetime = true,\n    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"my-super-secret\")),\n};  \nvar authResult = AuthUtility.ValidateBearerToken(context, 'token', validationParams);\n    if (authResult.IsAuthenticated)\n    {\n    //add more claims\n     authResult.claimsPrincipal.Claims.Append(new Claim(ClaimTypes.Age, 45));\n     return authResult;\n    }\n\n    return authResult;\n});\n</code></pre> <p>This authentication setup leverages the <code>ValidateBearerToken</code> utility to inspect and validate a JWT included in the request . The <code>TokenValidationParameters</code> object specifies how the token should be validated, such as the expected issuer, audience, lifetime, and signing key.</p> <p>If the token passes all checks, the utility returns an authenticated <code>AuthResponse</code>, which includes a <code>ClaimsPrincipal</code> populated with the claims that were originally embedded in the token when it was created.</p> <p>You can also append additional claims programmatically before returning the response, allowing for richer identity and authorization data within your application.</p>"},{"location":"Guide/","title":"Guide","text":"<p>This section explores Swytch's core features and how to use them effectively. You'll learn how to define routes, write handler methods, use middleware, serve static files, configure your application etc.  Each topic is explained with examples to help you get started quickly. Whether you're building a simple API, a full web app or even a static site, this section will expose to you everything you need to know to make the most of Swytch.</p>"},{"location":"Guide/#routing","title":"Routing","text":"<p>Swytch routes incoming requests by identifying its HTTP method and request path, and matching it against already registered routes. It considers both the HTTP request method and the exact path that came with the request. If no match is found, a 405 Method Not Allowed  response is returned. Swytch also supports dynamic path parameters, which you can define using curly braces like this <code>{name}</code> in the route path when registering or adding an action to your application. These parameters capture values from the URL as strings, with no automatic type conversion.  For example, a route like <code>/users/{id}</code> will match requests paths such as <code>/users/42</code>, where <code>42</code> is parsed, retrieved and provided(as the value of <code>id</code>) to you as a string. These captured path values, along with all query parameters, are made available  in the <code>RequestContext</code> type in the  <code>PathParams</code> and <code>QueryParams</code> collection properties, allowing easy access.</p>"},{"location":"Guide/#addaction","title":"AddAction","text":"<p>Routes in Swytch are registered using the <code>AddAction</code> method, which defines how requests should be handled. It takes three parameters:</p> <ol> <li>HTTP Methods \u2013 A capitalized string representing one or more HTTP methods (e.g., <code>\"GET\"</code>, <code>\"POST\"</code>, or <code>\"GET,POST\"</code>).</li> <li>Request Path \u2013 A path relative to the root (e.g., <code>\"/users/{id}\"</code>).</li> <li>Action Method \u2013 A method that can processes an incoming request.</li> </ol> <p>Note that routes are matched exactly, meaning <code>\"/about/\"</code> is not the same as <code>\"/about\"</code>.</p> <p>An action method, also known as a handler, is a method that processes an incoming request. For a method to be valid and qualify to process an incoming request, it must match the <code>Action&lt;Task, RequestContext&gt;</code> delegate, meaning it accepts a <code>RequestContext</code>type parameter and returns a <code>Task</code>. Note that instead inline lambdas like we have been doing all this while, we can also structure the code  differently by defining handler methods in a class and passing them by reference because remember a valid action method just has to satisfy an <code>Action&lt;Task, RequestContext&gt;</code> delegate . For example:</p> <pre><code>public class UserController {\n    public static async Task GetUser(RequestContext context) {\n        // Handle request\n    }\n}\n//usage \nvar  userController = new  UserController();\nswytchApp.AddAction(\"GET\", \"/users/{id}\", userController.GetUser);\n</code></pre> <p>This approach offers an alternative code organization approach by keeping route definitions clean while keeping handlers separate.</p>"},{"location":"Guide/#multiple-http-methods","title":"Multiple HTTP Methods","text":"<p><pre><code>swytchApp.AddAction(\"GET,POST\", \"/\", async (context) =&gt; {...});\n</code></pre> This ensures that both <code>GET</code> and <code>POST</code> requests to <code>\"/\"</code> are handled by the same action/handler method.</p>"},{"location":"Guide/#route-matching-order","title":"Route Matching Order","text":"<p>Routes are matched in the order they are registered. If you register the same path separately for different HTTP methods, the first one will always take precedence.</p> <p>For example:</p> <pre><code>swytchApp.AddAction(\"GET\", \"/submit\", async (context) =&gt; {...}));\nswytchApp.AddAction(\"POST\", \"/submit\", async (context) =&gt; {...}));\n</code></pre> <p>In this case, a <code>POST</code> request to <code>\"/about\"</code> will still match the first <code>GET</code> route, resulting in a 405 Method Not Allowed response.</p> <p>To prevent this, define both methods in a single <code>AddAction</code> and make a decision how you handle a request based on what HTTP method it came with:</p> <p><pre><code>app.AddAction(\"GET,POST\", \"/submit\",  async (context) =&gt; {\n\nif (context.Request.HttpMethod == \"POST\")\n{\n   //handle POST request\n   return;\n}\n//handle GET request\nawait context.ServeFile(\"SubmitPage.html\",HttpStatusCode.OK);\n\n});\n</code></pre> By doing this, both <code>GET</code> and <code>POST</code> requests will correctly match the intended handler.</p>"},{"location":"Guide/#middleware","title":"Middleware","text":"<p>Middleware concept in Swytch is simple and straightforward. Each middleware is queued for execution  before the request reaches the intended handler method. This allows you to do cool stuff like  modify the <code>RequestContext</code>, inspect, transform the request payload or enforce custom logic before the request is processed by the main handler.</p> <p>For example, Swytch's AddAuthentication method works by registering a middleware that will execute a user provided authentication method. This ensures that authentication checks are performed before the request reaches the actual  handler.</p> <p>To add custom middleware, you use the <code>AddMiddleware</code> method, which takes a single parameter, a method  matching the <code>Action&lt;RequestContext,Task&gt;</code> delegate. The order in which middlewares are registered  determines the order in which they execute.</p>"},{"location":"Guide/#example","title":"Example","text":"<pre><code>swytchApp.AddMiddleware(async (context) =&gt; {\n    context.Response.Headers[\"X-Custom-Header\"] = \"Middleware Added\";\n});\n</code></pre> <p>In this example, the middleware adds a custom header to every response before the request reaches its handler. Since middlewares execute in the order they are registered, later middlewares or the final  handler can rely on modifications made by earlier ones.</p>"},{"location":"Guide/#authentication","title":"Authentication","text":"<p>Swytch provides a mechanism to add authentication across your entire application or leave it completely open. Authentication is added using the <code>AddAuthentication</code> method on an instance of <code>SwytchApp</code>.</p> <p>By default, authentication is disabled. Calling <code>AddAuthentication</code> enables authentication, requiring  each request to pass an authentication check before reaching its intended handler.</p>"},{"location":"Guide/#how-it-works","title":"How It Works?","text":"<p>The <code>AddAuthentication</code> method takes a delegate of type <code>Action&lt;RequestContext, Task&lt;AuthResponse&gt;&gt;</code>, referred to as the AuthHandler. This method can be simply described an asynchronous method receives the <code>RequestContext</code> and must return an <code>AuthResponse</code>, which determines whether the request is authenticated or not.</p>"},{"location":"Guide/#authresponse","title":"AuthResponse","text":"<p>The AuthResponse struct represents the outcome of a request authentication in Swytch.Your  authentication logic should return an instance of AuthResponse, setting the <code>IsAuthenticated</code> property to true or false  based on whether the request is authenticated.</p> <p>Additionally, you can attach a ClaimsPrincipal to the AuthResponse instance using the <code>ClaimsPrincipal</code> property  which contains any claims related to  the authenticated user. These claims can be accessed downstream in your handler via <code>context.User</code>,  which is of type ClaimsPrincipal.</p> <p>When authentication is enabled, Swytch automatically queues the AuthHandler as middleware, meaning it executes on every incoming request. If authentication succeeds, the <code>IsAuthenticated</code> flag is set to <code>true</code>, allowing the request to proceed. If authentication fails, Swytch blocks the request before it  reaches any handler, ensuring unauthorized requests never reach protected resources.</p>"},{"location":"Guide/#example_1","title":"Example","text":""},{"location":"Guide/#add-a-authhandler","title":"Add A AuthHandler","text":"<pre><code>swytchApp.AddAuthentication(async (context) =&gt; {\n    var token = context.Request.Headers[\"Authorization\"];\n\n    // Simulate an async token validation\n    await Task.Delay(50);  \n\n    if (token == \"valid-token\")\n    {\n        var claims = new List&lt;Claim&gt;\n        {\n            new Claim(ClaimTypes.Name, \"JohnDoe\"),\n            new Claim(ClaimTypes.Role, \"Admin\")\n        };\n\n        var identity = new ClaimsIdentity(claims, \"Bearer\");\n        var principal = new ClaimsPrincipal(identity);\n\n        return new AuthResponse\n        {\n            IsAuthenticated = true,\n            ClaimsPrincipal = principal\n        };\n    }\n\n    return new AuthResponse { IsAuthenticated = false };\n});\n</code></pre> <p>In this example, the authentication handler checks for an <code>Authorization</code> header and validates it against a known token. If the token is valid, the request is authenticated and can proceed, otherwise it is blocked. With authentication enabled, every request must pass this check before reaching a registered route handler. If authentication fails, the request will not be processed further.</p>"},{"location":"Guide/#accessing-claims-and-authentication-status-in-a-handler","title":"Accessing Claims and Authentication Status in a Handler","text":"<p><pre><code>swytchApp.AddAction(\"GET\", \"/profile\", async (context) =&gt; {\n        var username = ctx.User?.FindFirst(ClaimTypes.Name)?.Value ?? \"Unknown\";\n        await context.ToOK(new { message = $\"Welcome, {username}!\" });\n    }\n});\n</code></pre> Note that there is no explicit authentication status check in the handler code.  This is because Swytch performs the authentication validation internally.If a request fails authentication, the handler method will not even be executed. This ensures that only authenticated requests reach your handler. Within your handler, you can directly access any claims set in the AuthResponse.</p>"},{"location":"Guide/#serving-static-content","title":"Serving Static Content","text":"<p>Swytch provides an extension method on <code>RequestContext</code> to serve static files from the <code>Statics</code> directory. This directory must be located in the root of the application's execution path, meaning it should be placed in the same directory where your application is running.</p> <p>The method takes in two parameters:</p> <ol> <li>File name  \u2013 The name of the file, including its extension.</li> <li>HTTP status code \u2013 The response status code, using <code>System.Net.HttpStatusCode</code>.</li> </ol> <p>If the specified file is not found in the <code>Statics</code> directory, a <code>FileNotFoundException</code> is thrown, caught, and logged.  Swytch then responds with a <code>404 Not Found</code> status code and the message <code>\"NOT FOUND (404)\"</code>.</p>"},{"location":"Guide/#example_2","title":"Example","text":"<pre><code>await context.ServeFile(\"logo.png\", HttpStatusCode.OK);\n</code></pre>"},{"location":"Guide/#swytch-static-file-server","title":"Swytch Static File Server","text":"<p>When enabled through the <code>SwytchConfig</code> type when creating an instance of <code>SwytchApp</code>, a built-in static  file handler is registered automatically for you. This handler intercepts and serves static files from the <code>Statics</code> directory without requiring you to write a custom handler that does this.</p>"},{"location":"Guide/#how-it-works_1","title":"How It Works?","text":"<p>Once the static file server is enabled, any request to the path: <code>/swytchserver/static/{filename}</code></p> <p>will be intercepted, and the requested file will be retrieved from the <code>Statics</code> directory and served automatically. The response will include a <code>Cache-Control</code> header, with the cache duration set to either the default  value or the one specified in <code>SwytchConfig</code>.</p> <p>This is very useful because it makes it easy to serve static files such as images, stylesheets, and JavaScript files without manually handling the request.Let's look at an example.</p>"},{"location":"Guide/#example_3","title":"Example","text":""},{"location":"Guide/#enabling-the-static-file-server","title":"Enabling the Static File Server","text":"<p>To enable the static file server, configure it when creating an instance of <code>SwytchApp</code>:</p> <pre><code>var swytchApp = new SwytchApp(new SwytchConfig \n{\n    EnableStaticFileServer = true,\n    StaticFileCacheMaxAge = 7200 // Cache files for 2 hours\n});\n</code></pre>"},{"location":"Guide/#using-static-file-server-in-html","title":"Using Static File Server in HTML","text":"<p><pre><code>&lt;img src=\"/swytchserver/static/logo.png\" alt=\"Logo\"&gt;\n</code></pre> This allows your Swytch application to serve static files seamlessly, making it practical for hosting images, scripts, and stylesheets without additional configuration.</p>"},{"location":"Guide/#serving-dynamic-templates","title":"Serving Dynamic  Templates","text":"<p>Swytch provides built-in support for dynamic content rendering using RazorLight. Templates are stored in the <code>Templates</code> directory, where Swytch automatically locates and renders them.</p>"},{"location":"Guide/#template-precompilation","title":"Template Precompilation","text":"<p>Template precompilation can be configured using the <code>SwytchConfig</code> class.When </p> <ul> <li>Enabled: Increases startup time relatively but ensures that all template page loads are instantaneous.</li> <li>Disabled (Default): Results in a relatively faster startup time, but the first request that renders a template page is   slower. However, all other subsequent loads will be  instantaneous.</li> </ul>"},{"location":"Guide/#methods-for-rendering-templates","title":"Methods for Rendering Templates","text":"<p>Swytch offers two methods for working with templates on the <code>SwytchApp</code> class:</p>"},{"location":"Guide/#generatetemplatestring-key-t-model","title":"GenerateTemplate(string key, T model) <p>This method generates a template and returns the result as a string.</p> <ul> <li>Parameters:<ul> <li><code>key</code> (string) \u2013 The filename of the template (without extension) located in the <code>Templates</code> directory.</li> <li><code>model</code> (T) \u2013 A model to be passed into the template for dynamic content rendering.Pass null if no dynamic data    need to be inserted.</li> <li></li> </ul> </li> </ul>","text":""},{"location":"Guide/#template-file-naming-and-directory","title":"Template File Naming and Directory <p>All template files must be placed inside a directory named <code>Templates</code> located in the root of your application. Each template should have the <code>.cshtml</code> extension.</p> <p>For example, a template named <code>welcome</code> must be saved as <code>/Templates/welcome.cshtml</code></p>","text":""},{"location":"Guide/#template-content-with-razor-syntax","title":"Template Content with Razor Syntax <p>Inside the <code>welcome.cshtml</code> file, you can write standard Razor syntax to bind and display data passed to it.</p> <pre><code>&lt;h1&gt;Welcome, @Model.Name!&lt;/h1&gt;\n&lt;p&gt;We\u2019re glad to have you here.&lt;/p&gt;\n</code></pre>  <p>You can check out the official Razor syntax documentation to learn how to write and structure your template files using Razor</p>  <p>You can render the above template from a route handler like indicated in the examples:</p> <ul> <li>Example Usage:</li> </ul> <pre><code>var content = swytchApp.GenerateTemplate(\"welcome\", new { Name = \"John Doe\" });\nConsole.WriteLine(content); \n</code></pre> <p>This will generate a string content with the welcome.cshtml template with the Name property dynamically inserted.</p>","text":""},{"location":"Guide/#rendertemplaterequestcontext-context-string-key-t-model","title":"RenderTemplate(RequestContext context, string key, T? model) <p>This method works like the <code>GenerateTemplate</code> method but instead of returning the generated contect , it  directly sends it as an HTTP response to the client.</p> <ul> <li>Parameters:<ul> <li><code>context</code> (RequestContext) \u2013 The current request context.</li> <li><code>key</code> (string) \u2013 The filename of the template (without extension) located in the <code>Templates</code> directory.</li> <li><code>model</code> (T) \u2013 A model to be passed into the template for rendering.</li> </ul> </li> </ul> <p>Example Usage:</p> <pre><code>swytchApp.AddAction(\"GET\", \"/welcome\", async ctx =&gt; \n{\n    await swytchApp.RenderTemplate(ctx, \"welcome\", new { Name = \"John Doe\" });\n});\n</code></pre> <p>When a client requests <code>/welcome</code>, Swytch will fetch the contexts of <code>welcome.cshml</code>, bind it with the provided model and return  the generated content as an HTTP response.</p>","text":""},{"location":"Guide/#database","title":"Database","text":""},{"location":"Guide/#working-with-databases","title":"Working with Databases <p>Swytch includes built-in support for relational databases through the powerful and lightweight Dapper micro-ORM. Dapper was chosen for its simplicity, lightweight footprint,  and easy-to-use APIs, making it a great fit for Swytch\u2019s minimalistic approach. Dapper allows you to execute SQL queries directly while taking care of parameter mapping, making it ideal for building data-driven applications without the overhead of a full ORM.</p>","text":""},{"location":"Guide/#registering-a-database-source","title":"Registering a Database Source <p>To begin working with a database in Swytch, you must first register it using the <code>AddDatastore</code> method available on your <code>ISwytchApp</code>(SwychApp) instance. This method stores the connection string along with the type of database provider, so Swytch can  later retrieve and create a proper connection when needed.</p> <p>The <code>AddDatastore</code> method accepts two parameters:</p> <ul> <li><code>connectionString</code> (string): The connection string used to connect to the database.</li> <li><code>provider</code> (<code>DatabaseProviders</code> enum): The type of database provider being registered.</li> </ul> <p>Swytch currently supports the following database providers through the <code>Swytch.Structures.DatabaseProviders</code> enum:</p> <ul> <li><code>DatabaseProviders.SqlServer</code> \u2013 Microsoft SQL Server</li> <li><code>DatabaseProviders.MySql</code> \u2013 MySQL</li> <li><code>DatabaseProviders.PostgreSql</code> \u2013 PostgreSQL</li> <li><code>DatabaseProviders.SQLite</code> \u2013 SQLite</li> <li><code>DatabaseProviders.Oracle</code> \u2013 Oracle</li> </ul> <p>When you call <code>AddDatastore</code>, Swytch will associate the provided connection string with the selected database provider internally. This registration must occur before attempting to use that provider or perform any database operations  in your app logic.</p>","text":""},{"location":"Guide/#retrieving-a-connection","title":"Retrieving a Connection <p>Once a datastore has been registered, you can obtain a connection to it using the <code>GetConnection</code> method. This method is also  defined on the <code>ISwytchApp</code> interface and is your main entry point for executing SQL commands via Dapper.</p> <p>The <code>GetConnection</code> method takes one parameter:</p> <ul> <li><code>provider</code> (<code>DatabaseProviders</code>): The type of database you want to connect to.</li> </ul> <p>It returns a raw connection object (e.g., <code>SqlConnection</code>, <code>NpgsqlConnection</code>, etc.) depending on the database provider you registered earlier.</p> <p>Some important notes:</p> <ul> <li> <p>If you call <code>GetConnection</code> with a provider that has not been registered using <code>AddDatastore</code>, a <code>KeyNotFoundException</code>  will be thrown.</p> </li> <li> <p>The returned connection implements <code>IDisposable</code>, meaning you should always dispose of it after use to avoid connection  leaks.</p> </li> </ul> <p>You can dispose of the connection using:</p> <ul> <li>A <code>using</code> block (<code>using var conn = ...</code>)</li> <li>Or calling <code>conn.Dispose()</code> manually</li> </ul>","text":""},{"location":"Guide/#example_4","title":"Example <p>Here's an example showing how to register a PostgreSQL database and use it to retrieve a list of users.</p> <pre><code>// Register the PostgreSQL database\nswytchApp.AddDatastore(\n    \"Host=localhost;Port=5432;Database=mydb;Username=myuser;Password=mypassword;\",\n    DatabaseProviders.PostgreSql\n);\n\n// Define a route that retrieves data from the database\nswytchApp.AddAction(\"GET\", \"/users\", async context =&gt;\n{\n    using var conn = swytchApp.GetConnection(DatabaseProviders.PostgreSql);\n\n    var users = await conn.QueryAsync&lt;User&gt;(\"SELECT * FROM users\");\n\n    await context.ToOk(users);\n});\n</code></pre>","text":""},{"location":"Help/","title":"Help","text":"<p>This section covers common questions, issues, and challenges developers may encounter while working with Swytch. Whether it is setting up authentication, troubleshooting unexpected behavior, or looking for workarounds to specific limitations.</p> <p>If you're running into something that isn't documented yet, chances are others might too,so users are strongly encouraged to open an issue or start a discussion if they encounter a problem or challenge. These reports not only help improve Swytch but also allow us to document solutions and make them available here to help other users</p>"},{"location":"Installation/","title":"Installing","text":""},{"location":"Installation/#make-sure-net-sdk-is-available","title":"Make sure .Net SDK is available","text":"<p>Swytch a .NET C# Web framework, hence to use it you'll need the .NET SDK installed on your machine. If you don't, you can download and install it from the official .NET website.</p> <p>Once installed, verify the installation by running</p> <pre><code> dotnet --version\n</code></pre>"},{"location":"Installation/#create-a-project","title":"Create A Project","text":"<p>The foundation of a swytch app is nothing but a console application. So we shall create a simple boring console app and then supercharge it with all the amazing features Swytch has to offer.</p> <p>Note that Swytch has starter templates that can be used to quickly bootstrap a project and get up and running quickly. We shall later take a look at that under the Swytch templates section but  for now let's set up everything from the ground up to have a better perspective into what makes a Swytch application.</p> <p>First create a console application like you always do <pre><code>dotnet new console -n MyFistSwytchApp\ncd MyFirstSwytchApp\n</code></pre></p> <p>Inside the <code>MyFirstSwytchApp</code> directory, you can optionally rename the <code>Program.cs</code> file to <code>Server.cs</code> In Swytch, this will be the entry point of your application. This is just a convention for consistency, and you can name the file however you like. However throughout this documentation, this covention will be used and whenever you see <code>Server.cs</code> you should know that this is just the entry point  of your application just like the <code>Program.cs</code> file you're used to.</p>"},{"location":"Installation/#adding-nuget-package","title":"Adding Nuget Package","text":"<p>You can easily add Swytch to your project using the Nuget package.</p> <pre><code> dotnet add package Swytch \n</code></pre> <p>or maybe a specific version with</p> <pre><code> dotnet add package Swytch --Version &lt;number&gt;\n</code></pre> <p>alternatively you can add the package reference to your project's <code>.csproj</code> file</p> <pre><code>&lt;PackageReference Include=\"Swytch\" /&gt;\n</code></pre> <p> NEXT </p>"},{"location":"Quickstart/","title":"Quickstart","text":"<p>Ready to get started? In this section we shall get an introduction to Swytch. Be sure  to follow the installation to set up a project and install Swytch first.</p>"},{"location":"Quickstart/#a-basic-swytch-app","title":"A Basic Swytch App","text":"<p>A Swytch application in its most minimal and basic form will look something like this: </p> <pre><code>using System.Net;\nusing Swytch.App;\nusing Swytch.Extensions;\n\n\nSwytchApp swytchApp = new SwytchApp();\n\nswytchApp.AddAction(\"GET\",\"/\", async (context) =&gt;\n{\n    await context.WriteHtmlToStream(\"&lt;h1&gt;Hello from swytch&lt;h1&gt;\", HttpStatusCode.OK);\n});\n\nawait swytchApp.Listen();\n</code></pre> <p>Replace the content of Server.cs with this code block.</p> <p>This is a simple Swytch application that starts a server that listens on the default URI prefix <code>http://127.0.0.1:8080/</code> and returns an HTML response to all HTTP GET requests to the root path or <code>/</code>. For every other path it shall respond with a  404 Not Found and request to the root path with any other method apart  from HTTP GET will ge 405 Method Not Allowed.</p> <p>Now let's go over  what this code does line by line.</p> <ol> <li> <p>First, we specify all the namespaces which contains the methods and classes that serve our purpose.</p> </li> <li> <p>Then we go ahead and create an instance on a swytchApp.</p> </li> <li> <p>Next we configure our Swytch app to perform a specific action when we receive a GET request on the root path(<code>/</code>) using the <code>AddAction</code> method. We shall refer to this as adding an action to our Swytch app. The method takes in 3 parameters. First is the HTTP method(s) on which we should perform the action, the second is the path and the third is the action method/handler method itself. You will find more information on what the action method is, how to write it and different ways of using it in the guide section.</p> </li> <li> <p>Finally, we start our server and wait for requests.</p> </li> </ol> <p>To run the application simply make sure you're in the project root and then execute <code>Dotnet run</code> in the terminal  or just start it from your IDE with whatever button provided and navigate to <code>http://127.0.0.1:8080/</code> in your browser.</p>"},{"location":"Quickstart/#swytchapp","title":"SwytchApp","text":"<p><code>SwytchApp</code> represents the running application. An instance of this class is your web application or server. It holds all configurations, including route definitions, server settings, static file caching policies etc.</p> <p>You can configure your <code>SwytchApp</code> using the SwytchConfig class, which provides sensible defaults.  For example, the default configuration for the above application has cache max age is <code>3600</code> seconds, and template precompilation is disabled (<code>false</code>). But we can change that with.</p> <pre><code>SwytchApp swytchApp  = new SwytchApp(new SwytchConfig\n{\n    StaticCacheMaxAge = 7200, // Set cache max age to 2 hours\n    PrecompileTemplates = true // Enable precompilation\n});\n</code></pre>"},{"location":"Quickstart/#routing","title":"Routing","text":"<p>Swytch configures routing through the <code>AddAction</code> method, where you define the HTTP method(s), the route path, and the handler method. Note that routes are matched exactly, meaning <code>\"/about/\"</code> is not the same as <code>\"/about\"</code>.</p> <p>The route registration in the above application specifies just one HTTP method,but we can be fancier  and allow  multiple HTTP methods on the same route by separating them with a comma:</p>"},{"location":"Quickstart/#multiple-http-methods","title":"Multiple HTTP Methods","text":"<p><pre><code>swytchApp.AddAction(\"GET,POST\", \"/\", async (context) =&gt; {...});\n</code></pre> This ensures that both <code>GET</code> and <code>POST</code> requests to <code>\"/\"</code> are handled by the same action/handler method.</p>"},{"location":"Quickstart/#route-matching-order","title":"Route Matching Order","text":"<p>Routes are matched in the order they are registered. If you register the same path separately for different HTTP methods,  the first one will always take precedence.</p> <p>For example:</p> <pre><code>app.AddAction(\"GET\", \"/submit\", async (context) =&gt; {...}));\napp.AddAction(\"POST\", \"/submit\", async (context) =&gt; {...}));\n</code></pre> <p>In this case, a <code>POST</code> request to <code>\"/about\"</code> will still match the first <code>GET</code> route, resulting in a 405 Method Not Allowed response.</p> <p>To prevent this, define both HTTP methods to be handled by a single <code>AddAction</code> and make a decision how you handle a request based on what HTTP method it came with:</p> <p><pre><code>app.AddAction(\"GET,POST\", \"/submit\",  async (context) =&gt; {\n\nif (context.Request.HttpMethod == \"POST\")\n{\n   //handle POST request\n   return;\n}\n//handle GET request\nawait context.ServeFile(\"SubmitPage.html\",HttpStatusCode.OK);\n\n});\n</code></pre> By doing this, both <code>GET</code> and <code>POST</code> requests will correctly match the intended handler.</p>"},{"location":"Quickstart/#response-extensions","title":"Response Extensions","text":"<p>Swytch provides handy extension methods on the <code>RequestContext</code> type to quickly send HTTP responses  like  <code>WriteHtmlToStream</code> and <code>ServeFile</code> used in the code samples above. You can find these methods in the <code>Swytch.Extensions</code> namespace.</p> <p>For a full list of response methods and utilites currently available, check the request context extensions page.</p>"},{"location":"Quickstart/#starting-the-application","title":"Starting the Application","text":"<p>After configuring your  instance of <code>SwytchApp</code>, you finally call the <code>Listen</code> method and start the application. By default, it listens on port <code>8080</code>:</p> <pre><code>await app.Listen();\n</code></pre> <p>You can specify a different URL prefix if needed:</p> <pre><code>await app.Listen(\"http://localhost:5000/\");\n</code></pre> <p>Note: The URL prefix must end with a trailing <code>/</code>, or an ArgumentException will be thrown.</p> <p>Also, always <code>await</code> this call, if not, the server will start and immediately exit.  </p>"},{"location":"ReleaseNotes/","title":"Overview","text":"<p>List of all published version of Swytch and their accompanying release notes.</p>"},{"location":"ReleaseNotes/#100","title":"1.00","text":""},{"location":"ReleaseNotes/#swytch-v100-first-stable-release","title":"Swytch v1.0.0 \u2014 First Stable Release","text":"<p>Excited to announce the first stable release of Swytch, version <code>1.0.0</code>!</p> <p>Swytch is a fast, lightweight, developer-friendly alternate web framework written in C#. It is designed for building modern APIs, web apps, and static sites with minimal friction.</p> <p>This release completes the core framework features and serves as a solid foundation for building exciting and robust web applications.</p> <p>I encourage you to give it a try and hope you will be kind enough to share any feedback you have. I would like to know how practical it is for users other than myself.</p>"},{"location":"ReleaseNotes/#core-features","title":"Core Features","text":"<ul> <li>Simple and flexible routing system</li> <li>Path Parameters</li> <li>JSON and template-based response support</li> <li>Built-in authentication utilities (Basic &amp; JWT)</li> <li>Middleware pipeline support</li> <li>Static file server</li> <li>Actor-based asynchronous job execution</li> <li>Built in lightweight ORM</li> <li>Ready-to-use starter templates:<ul> <li><code>swytch-api-lite</code></li> <li><code>swytch-api</code></li> <li><code>swytch-web</code></li> </ul> </li> </ul>"},{"location":"RequestContext/","title":"RequestContext","text":"<p>The <code>RequestContext</code> class in Swytch is designed to encapsulate all relevant information about an HTTP request being handled, providing convenient access to details of the request and the response. Here you will find an overview of the key properties, methods, extensions and their roles.</p> <p>RequestContext class is a custom type that essentially wraps desired members of the HttpListenerContext class which in this case is the HttpListenerRequest, HttpListenerResponse, the ClaimsPrincipal object which represents the current client whose request is being handled. Some additional members include the query and path parameters properties which will hold all query and path parameters supplied in a request</p>"},{"location":"RequestContext/#properties","title":"Properties","text":""},{"location":"RequestContext/#httplistenerrequest","title":"<code>HttpListenerRequest</code>","text":"<p>This property holds the incoming HTTP request. It contains essential information about the request made by the client, including the HTTP method (such as GET, POST, etc.), headers, and the body content. You can use this property to access raw data about the client's request and handle it appropriately.</p>"},{"location":"RequestContext/#httplistenerresponse","title":"<code>HttpListenerResponse</code>","text":"<p>The <code>Response</code> property represents the HTTP response that will be sent back to the client. With this, you can modify the response by setting the status code, adding headers, and writing the response body. This is essential for shaping what the client will receive after the request is processed.</p>"},{"location":"RequestContext/#user","title":"<code>User</code>","text":"<p>The <code>User</code> property represents the client who made the request. It is an instance of <code>ClaimsPrincipal</code> and contains information about the user's identity, including any claims they may have (such as roles, permissions, or other authentication data). If authentication has failed, this property can be <code>null</code>, indicating there is no authenticated user. This is particularly useful for handling authentication and authorization in your application.</p>"},{"location":"RequestContext/#pathparams","title":"<code>PathParams</code>","text":"<p>The <code>PathParams</code> property holds a collection of path parameters extracted from the URL. For instance, if the route is <code>/user/{id}</code>, and the incoming request is <code>/user/123</code>, this dictionary will contain the pair <code>{\"id\": \"123\"}</code>. These parameters are crucial for handling dynamic parts of a route, allowing your application to adapt to different requests based on the URL structure.</p>"},{"location":"RequestContext/#queryparams","title":"<code>QueryParams</code>","text":"<p>This property stores the query parameters from the URL's query string. For example, a request to <code>/search?query=test&amp;page=2</code> will populate the <code>QueryParams</code> dictionary with the values <code>{\"query\": \"test\", \"page\": \"2\"}</code>. This makes it easy to work with parameters passed in the query string, which are often used to filter or paginate results in web applications.</p>"},{"location":"RequestContext/#isauthenticated","title":"<code>IsAuthenticated</code>","text":"<p>The <code>IsAuthenticated</code> property is a boolean flag indicating whether the request has passed the authentication logic. If this value is <code>true</code>, it means the request has been authenticated successfully. If it is <code>false</code>, the request has not been authenticated. This property is useful when you need to ensure that a request is valid and from an authenticated user before processing it further.</p>"},{"location":"RequestContext/#contextbag","title":"<code>ContextBag</code>","text":"<p>This dictionary allows middleware and handlers to attach or retrieve contextual information during request processing. It acts as a shared space for passing data between components without requiring tight coupling.</p>"},{"location":"RequestContext/#why-is-requestcontext-important","title":"Why is <code>RequestContext</code> Important?","text":"<p>The <code>RequestContext</code> is crucial because it bundles all the essential information about the HTTP request and the response. T his makes it easy for your application to interact with both the request and the response without needing to repeatedly access lower-level data structures. Since most response extension methods are provided through <code>RequestContext</code>, it serves as the central point for working with HTTP requests and responses. By passing the <code>RequestContext</code> to your handler methods, you ensure that each method can access the relevant details specific to the current request, such as parameters, headers, and authentication status. This not only simplifies request handling but also makes your code more maintainable and modular.</p>"},{"location":"RequestContext/#instance-methods","title":"Instance Methods","text":"<p>The <code>RequestContext</code> class provides several important instance methods that allow you to easily process incoming request data, making it simpler for your application to handle various types of HTTP requests. These methods help you interact with the request body and extract data in formats such as JSON, raw text, or form-encoded data. Below are the key methods provided by the <code>RequestContext</code> instance.</p>"},{"location":"RequestContext/#readjsonbody","title":"<code>ReadJsonBody</code>","text":"<p>This method reads the JSON-formatted body of the HTTP request and returns it as a string. It expects the <code>Content-Type</code> header to be set to <code>application/json</code>. If the content type does not match, an <code>InvalidDataException</code> is thrown. This method is useful when the request body is expected to be in JSON format and you need to process it as a raw string.</p>"},{"location":"RequestContext/#readjsonbodyt","title":"<code>ReadJsonBody&lt;T&gt;</code>","text":"<p>Similar to the <code>ReadJsonBody()</code> method, this one reads the JSON-formatted body of the HTTP request but deserializes it directly into the specified type <code>T</code>. The <code>Content-Type</code> header must be set to <code>application/json</code>. This method is convenient when you want to work with strongly-typed objects and parse the request body into a specific class or data structure.</p>"},{"location":"RequestContext/#readrawbody","title":"<code>ReadRawBody</code>","text":"<p>This method reads the raw content of the request body as a string, without any parsing or transformation. It is ideal when you want to handle arbitrary data formats or need to process the body without any assumptions about its structure. This method provides a flexible way to retrieve the entire content as-is.</p>"},{"location":"RequestContext/#readformbody","title":"<code>ReadFormBody</code>","text":"<p>This method reads the request body when the <code>Content-Type</code> header is set to <code>application/x-www-form-urlencoded</code>. It returns the body content as a <code>NameValueCollection</code>, which contains the form fields and their associated values. This is particularly useful for handling traditional form submissions, where data is encoded as key-value pairs.</p>"},{"location":"RequestContext/#extension-methods","title":"Extension Methods","text":"<p>The <code>IRequestContext</code> interface provides several  extension methods that allow you to easily send HTTP responses back to the client. These methods are useful because they provide an easy interface to write to the response stream, set appropriate status codes, and format the response content as needed. The methods are designed to work seamlessly with the <code>RequestContext</code> since it already holds all the necessary information about the current request.</p>"},{"location":"RequestContext/#writetexttostream","title":"<code>WriteTextToStream</code>","text":"<p>This method writes a plain text response with the specified payload and status code. You can use it to return   string-based content, such as error messages or success messages, to the client.</p>"},{"location":"RequestContext/#writehtmltostream","title":"<code>WriteHtmlToStream</code>","text":"<p>Similar to the text response, this method writes an HTML response to the client. You can pass HTML content as a   string,   and it will be returned with the appropriate status code. This is useful for returning web pages or HTML-based   content.   Be sure to excape html content if they are from users to avoid injection as the method does no escaping and   sends the html content as-is.</p>"},{"location":"RequestContext/#writejsontostreamt","title":"<code>WriteJsonToStream&lt;T&gt;</code>","text":"<p>This method serializes an object of type <code>T</code> into a JSON format and writes it to the response body. It also sets the   status code for the response. This is typically used for API responses where JSON is the expected format.</p>"},{"location":"RequestContext/#servefile","title":"<code>ServeFile</code>","text":"<p>This method serves static files from the server. It reads a file from the <code>/statics</code> directory (inside the   application's base directory) and streams it to the client. This is useful for serving assets like images, CSS files,   JavaScript files, etc.</p>"},{"location":"RequestContext/#tookt","title":"<code>ToOk&lt;T&gt;</code>","text":"<p>This method returns an HTTP response with a status code of <code>200 OK</code> and the provided payload. It's often used for   successful responses where you return data in the body of the response.</p>"},{"location":"RequestContext/#tocreatedt","title":"<code>ToCreated&lt;T&gt;</code>","text":"<p>This method responds with a <code>201 Created</code> status code and the provided payload. </p>"},{"location":"RequestContext/#toacceptedt","title":"<code>ToAccepted&lt;T&gt;</code>","text":"<p>This method returns a <code>202 Accepted</code> status code, indicating that the request has been accepted for processing, but   the actual processing may not be completed yet. It includes a payload, which may contain additional information or the   state of the request.</p>"},{"location":"RequestContext/#toredirect","title":"<code>ToRedirect</code>","text":"<p>This method issues a <code>302 Found</code> redirect response, redirecting the client to the specified path. Optionally, query   parameters can be included in the redirect URL.</p>"},{"location":"RequestContext/#topermanentredirect","title":"<code>ToPermanentRedirect</code>","text":"<p>Similar to <code>ToRedirect</code>, but this method issues a <code>301 Moved Permanently</code> response, indicating that the resource has   permanently moved to the new location specified in the <code>path</code>.</p>"},{"location":"RequestContext/#tobadrequestt","title":"<code>ToBadRequest&lt;T&gt;</code>","text":"<p>This method returns a <code>400 Bad Request</code> status code, typically used when the client sends invalid data. The <code>payload</code>   provides more context about the error.</p>"},{"location":"RequestContext/#tounauthorizedt","title":"<code>ToUnauthorized&lt;T&gt;</code>","text":"<p>This method sends a <code>401 Unauthorized</code> status code, used when authentication is required but not provided or invalid.   The <code>payload</code> contains information about the authentication failure.</p>"},{"location":"RequestContext/#toforbiddent","title":"<code>ToForbidden&lt;T&gt;</code>","text":"<p>This method sends a <code>403 Forbidden</code> status code, indicating that the client is authenticated but does not have   permission to access the requested resource.</p>"},{"location":"RequestContext/#tonotfoundt","title":"<code>ToNotFound&lt;T&gt;</code>","text":"<p>This method sends a <code>404 Not Found</code> status code when the requested resource cannot be found. The <code>payload</code> can contain   details or a message explaining the error.</p>"},{"location":"RequestContext/#tointernalerror","title":"<code>ToInternalError</code>","text":"<p>This method sends a <code>500 Internal Server Error</code> status code along with a meaningful message. It's typically used when   there is an error on the server-side that prevents the request from being fulfilled.</p>"},{"location":"RequestContext/#tonotimplemented","title":"<code>ToNotImplemented</code>","text":"<p>This method returns a <code>501 Not Implemented</code> status code, indicating that the requested functionality is not supported   by the server.</p>"},{"location":"RequestContext/#toresponset","title":"<code>ToResponse&lt;T&gt;</code>","text":"<p>This method allows you to manually specify the HTTP status code and response data (<code>payload</code>). It's a flexible method   for sending any type of response, with the status code and content of your choice.</p>"},{"location":"SwytchTemplates/","title":"Swytch templates","text":"<p>Swytch provides a collection of official starter templates to help you get up and running with your projects faster. These templates are designed to eliminate the need for repetitive boilerplate setup, letting you jump straight into building your application. Whether you're creating a lean API, a more structured backend, or a server-rendered web application, Swytch's starter templates offer flexible starting points suited to your development needs.</p> <p>Currently, Swytch has a template pack with three templates:</p> <ul> <li><code>swytch-api-lite</code> \u2013 A lightweight API template with all routing and logic defined inline in the <code>Server.cs</code> file.   Ideal for small projects and quick prototypes.</li> <li><code>swytch-api</code> \u2013 A structured API template that separates routing and handler logic, organizing handlers in an   <code>Actions/</code> directory.</li> <li><code>swytch-web</code> \u2013 A web application template pre-configured with Swytch's templating engine and routing capabilities.   Perfect for building dynamic server-rendered sites.</li> </ul> <p>Each template reflects a different architectural approach using a playlist application while maintaining Swytch\u2019s simplicity and developer-first philosophy. You can choose the one that fits your use case and evolve your app from there.</p> <p>Now let's explore them in more detail.</p>"},{"location":"SwytchTemplates/#installation","title":"Installation","text":""},{"location":"SwytchTemplates/#installing-the-swytch-template-pack","title":"Installing the Swytch Template Pack","text":"<p>To start using Swytch templates, you first need to install the Swytch template pack from NuGet. This gives you access to all available Swytch starter templates directly through the .NET CLI.</p> <p>Run the following command:</p> <pre><code>dotnet new install Swytch.Template.Pack::1.0.0\n</code></pre>"},{"location":"SwytchTemplates/#usage","title":"Usage","text":""},{"location":"SwytchTemplates/#creating-starting-projects-with-the-templates","title":"creating / starting projects with the templates","text":""},{"location":"SwytchTemplates/#swytch-api","title":"Swytch API","text":"<pre><code>dotnet new swytch-api -n MyApi\n</code></pre>"},{"location":"SwytchTemplates/#sample-output","title":"Sample output \ud83d\udce6","text":"<pre><code>MySwytchApi/\n\u251c\u2500\u2500 Actions/PlaylistAction.cs\n\u251c\u2500\u2500 DTOs/AddPlaylist.cs, AddSong.cs\n\u251c\u2500\u2500 Helpers/DatabaseHelpers.cs\n\u251c\u2500\u2500 Models/Playlist.cs, Song.cs\n\u251c\u2500\u2500 Services/\n\u2502   \u251c\u2500\u2500 Interfaces/IPlaylistService.cs\n\u2502   \u2514\u2500\u2500 Implementation/PlaylistService.cs\n\u251c\u2500\u2500 Statics/index.html, logo-5.png\n\u251c\u2500\u2500 Server.cs\n\u2514\u2500\u2500 Swytch-Api-Template.csproj\n</code></pre>"},{"location":"SwytchTemplates/#swytch-api-lite","title":"Swytch API Lite","text":"<pre><code>dotnet new swytch-api-lite -n MyApi\n</code></pre>"},{"location":"SwytchTemplates/#sample-output_1","title":"Sample output \ud83d\udce6","text":"<pre><code>MySwytchApi/\n\u251c\u2500\u2500 DTOs/AddPlaylist.cs, AddSong.cs\n\u251c\u2500\u2500 Helpers/DatabaseHelpers.cs\n\u251c\u2500\u2500 Models/Playlist.cs, Song.cs\n\u251c\u2500\u2500 Services/\n\u2502   \u251c\u2500\u2500 Interfaces/IPlaylistService.cs\n\u2502   \u2514\u2500\u2500 Implementation/PlaylistService.cs\n\u251c\u2500\u2500 Statics/index.html, logo-5.png\n\u251c\u2500\u2500 Server.cs\n\u2514\u2500\u2500 Swytch-Api-Lite-Template.csproj\n</code></pre>"},{"location":"SwytchTemplates/#swytch-web","title":"Swytch Web","text":"<pre><code>dotnet new swytch-web -n MyWebApp\n</code></pre>"},{"location":"SwytchTemplates/#sample-output_2","title":"Sample output \ud83d\udce6","text":"<pre><code>MySwytchApi/\n\u251c\u2500\u2500 Actions/PlaylistAction.cs\n\u251c\u2500\u2500 DTOs/AddPlaylist.cs, AddSong.cs\n\u251c\u2500\u2500 Helpers/DatabaseHelpers.cs\n\u251c\u2500\u2500 Models/Playlist.cs, Song.cs,  ViewList.cs\n\u251c\u2500\u2500 Services/\n\u2502   \u251c\u2500\u2500 Interfaces/IPlaylistService.cs\n\u2502   \u2514\u2500\u2500 Implementation/PlaylistService.cs\n\u251c\u2500\u2500 Statics/logo-5.png, Style.css\n\u251c\u2500\u2500 Templates/AddSong.cshtml,BrowsePlaylist.cshtml,CreatePlaylist.cshtml,DeletePlaylist.cshtml,Layout.cshtml,PlaylistOperations.cshtml,ViewPlaylist.cshtml\n\u251c\u2500\u2500 Server.cs\n\u2514\u2500\u2500 Swytch-Web-Template.csproj\n</code></pre>"}]}